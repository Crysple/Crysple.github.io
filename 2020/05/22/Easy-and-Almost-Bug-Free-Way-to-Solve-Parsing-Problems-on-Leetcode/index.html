<!DOCTYPE html>
<html lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta property='og:image' content="/img/ogimage.jpeg">
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/avatar.jpeg">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/avatar.jpeg">
  <link rel="mask-icon" href="/img/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideRightIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="What it solves forParsing problems on leetcode are usually hard to write, hard to debug and variable for different situations, which makes it time-consuming. Sample problems might be the series of cal">
<meta name="keywords" content="Coding">
<meta property="og:type" content="article">
<meta property="og:title" content="Easy and Almost-Bug-Free Way to Solve Parsing Problems on Leetcode">
<meta property="og:url" content="http://yoursite.com/2020/05/22/Easy-and-Almost-Bug-Free-Way-to-Solve-Parsing-Problems-on-Leetcode/index.html">
<meta property="og:site_name" content="Zejun Lin&#39;s Blog">
<meta property="og:description" content="What it solves forParsing problems on leetcode are usually hard to write, hard to debug and variable for different situations, which makes it time-consuming. Sample problems might be the series of cal">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://yoursite.com/img/post_img/BNF_Tree.png">
<meta property="og:updated_time" content="2020-06-25T16:19:13.725Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Easy and Almost-Bug-Free Way to Solve Parsing Problems on Leetcode">
<meta name="twitter:description" content="What it solves forParsing problems on leetcode are usually hard to write, hard to debug and variable for different situations, which makes it time-consuming. Sample problems might be the series of cal">
<meta name="twitter:image" content="http://yoursite.com/img/post_img/BNF_Tree.png">

<link rel="canonical" href="http://yoursite.com/2020/05/22/Easy-and-Almost-Bug-Free-Way-to-Solve-Parsing-Problems-on-Leetcode/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Easy and Almost-Bug-Free Way to Solve Parsing Problems on Leetcode | Zejun Lin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Zejun Lin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">异国漂泊，野蛮生长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/22/Easy-and-Almost-Bug-Free-Way-to-Solve-Parsing-Problems-on-Leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/avatar.jpeg">
      <meta itemprop="name" content="Daniel">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zejun Lin's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Easy and Almost-Bug-Free Way to Solve Parsing Problems on Leetcode
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-22 23:34:26" itemprop="dateCreated datePublished" datetime="2020-05-22T23:34:26-04:00">2020-05-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-25 12:19:13" itemprop="dateModified" datetime="2020-06-25T12:19:13-04:00">2020-06-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Coding/" itemprop="url" rel="index"><span itemprop="name">Coding</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="What-it-solves-for"><a href="#What-it-solves-for" class="headerlink" title="What it solves for"></a>What it solves for</h1><p><strong>Parsing problems</strong> on leetcode are usually <strong>hard to write,</strong> <strong>hard to debug</strong> and <strong>variable</strong> for different situations, which makes it time-consuming. Sample problems might be the series of <strong>calculators</strong>. If you are trying to find <strong>a general, easy way (almost no annoying bugs after you finish it too!)</strong> to solve this kind of problems, then you should read this.</p>
<p>Basically this post introduce simple <strong>BNF</strong> and a easy-to-write <strong>Recursive Descent Parsing template</strong> to implement BNF.</p>
<ul>
<li><p>Sample Problems on Leetcode</p>
<p><a href="https://leetcode.com/problems/basic-calculator" target="_blank" rel="noopener">224. Basic Calculator</a></p>
<p><a href="https://leetcode.com/problems/basic-calculator-ii" target="_blank" rel="noopener">227. Basic Calculator II</a></p>
<p><a href="https://leetcode.com/problems/basic-calculator-iii" target="_blank" rel="noopener">772. Basic Calculator III</a></p>
<p><a href="https://leetcode.com/problems/basic-calculator-iv" target="_blank" rel="noopener">770. Basic Calculator IV</a></p>
<p><a href="https://leetcode.com/problems/mini-parser" target="_blank" rel="noopener">385. Mini Parser</a></p>
<p><a href="https://leetcode.com/problems/decode-string" target="_blank" rel="noopener">394. Decode String</a></p>
<p><a href="https://leetcode.com/problems/ternary-expression-parser" target="_blank" rel="noopener">439. Ternary Expression Parser</a></p>
</li>
</ul>
<a id="more"></a>
<h1 id="Backus-Naur-Form-BNF-Grammar"><a href="#Backus-Naur-Form-BNF-Grammar" class="headerlink" title="Backus-Naur Form (BNF) Grammar"></a>Backus-Naur Form (BNF) Grammar</h1><p>Wiki defines <a href="https://en.wikipedia.org/wiki/Backus–Naur_form" target="_blank" rel="noopener">BNF</a> as a <strong>notation technique</strong> for <strong>context-free grammars</strong>, often used to describe the syntax of languages such as computer programming languages. Please don’t be deterred by this abstract concept. It will be quite clear and simple after walking through an example. (If you have taken compiler class before, you can skip this chapter…)</p>
<p>A basic example might be <a href="https://leetcode.com/problems/basic-calculator-ii" target="_blank" rel="noopener">Basic Calculator II</a>, which asks to write a calculator for expression only with <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and positive numbers. The BNF that <strong>describes</strong> the <strong>syntax</strong> of such an <strong>expression</strong> looks like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Expr&gt; ::= &lt;Term&gt; &#123;(+|-) &lt;Term&gt;&#125;</span><br><span class="line">&lt;Term&gt; ::= &lt;Number&gt; &#123;(*|/) &lt;Number&gt;&#125;</span><br><span class="line">&lt;Number&gt; ::= &lt;Digit&gt;&#123;&lt;Digit&gt;&#125;</span><br><span class="line">&lt;Digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span><br></pre></td></tr></table></figure>
<p>Let me explain the symbols used here. Usually a BNF is consisted of the following:</p>
<ul>
<li><code>Non-terminals</code>:  names enclosed in <code>&lt;</code>, <code>&gt;</code> like <code>&lt;Number&gt;</code>, which can <strong>generate a kind of expression</strong> — usually consisting of different <code>terminals</code> and <code>non-terminal</code></li>
<li><code>Terminals</code>: characters like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>1</code>, <code>2</code>, …,  which <strong>cannot generate into another expression</strong>.</li>
<li><code>::=</code>: Just like an assignment, interpreted as “<strong>is defined as</strong>“. It describes that the left-hand-side <code>Non-terminals</code> will generate an <strong>expression</strong> in the right-hand-side. For each statement like this, we call it a <strong>production</strong>.</li>
<li><code>|</code>: A <code>Non-terminals</code> might generate into <strong>different expressions</strong>, you can use <code>|</code> to <strong>separate</strong> them, which means <strong>OR</strong>. Note that it has the lowest priority, so if you want to expression an <strong>or</strong> between two small items, use <code>()</code> to group them.</li>
<li><code>{}</code>: Items existing <strong>0 or more times</strong> are enclosed in curly brackets</li>
<li><code>[]</code>: Optional items enclosed in square brackets</li>
</ul>
<p>So how is this BNF <strong>related</strong> to the calculator I described above?</p>
<p>Well, you can use this BNF, specifically, the <code>&lt;Expr&gt;</code> non-terminal to <strong>generate all legal expressions</strong> of this calculator. Let me explain each production below:</p>
<ul>
<li><code>&lt;Expr&gt; ::= &lt;Term&gt; {(+|-) &lt;Term&gt;}</code>: An <code>&lt;Expr&gt;</code> might be one or multiple <code>&lt;Term&gt;</code> concatenated by <code>+</code> or <code>-</code>.</li>
<li><code>&lt;Term&gt; ::= &lt;Number&gt; {(*|/) &lt;Number&gt;}</code>: Similarly, each <code>&lt;Term&gt;</code> is either a <code>&lt;Number&gt;</code> or muliple <code>&lt;Numbere&gt;</code> concatenated by <code>*</code> or <code>/</code>.<ul>
<li>Note that we distinguish <code>&lt;Expr&gt;</code> and <code>&lt;Term&gt;</code> because the priority of <code>*</code> and <code>/</code> is higher than <code>+</code> and <code>-</code>, which helps to calculate correctly.</li>
</ul>
</li>
<li><code>&lt;Number&gt; ::= &lt;Digit&gt;{&lt;Digit&gt;}</code>: a <code>&lt;Number&gt;</code> is consisting of one or more <code>&lt;Digit&gt;</code>.</li>
<li><code>&lt;Digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</code>: this one is obviouse, a <code>&lt;Digit&gt;</code> is just a digit.</li>
</ul>
<p>An example — <strong>12 + 4 * 21 - 3​</strong> can be described as the BNF tree below:</p>
<p><img src="/img/post_img/BNF_Tree.png" alt="BNF_tree"></p>
<h1 id="Converting-BNF-to-C-code-—-Recursive-Descent-Parsing"><a href="#Converting-BNF-to-C-code-—-Recursive-Descent-Parsing" class="headerlink" title="Converting BNF to C++ code — Recursive Descent Parsing"></a>Converting BNF to C++ code — Recursive Descent Parsing</h1><p>There are many ways to implement a BNF parser depending on the complexity of the grammar. Usually for problems on leetcode, a simplest <strong><a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" target="_blank" rel="noopener">Predictive Recursive Descent Parser</a></strong>. Note that it is only possible for the class of <strong><a href="https://en.wikipedia.org/wiki/LL_parser" target="_blank" rel="noopener">LL(<em>k</em>)</a> grammars</strong>. Here, <strong>LL(k)</strong> means you can <strong>decide which production to use</strong> by examining only the <strong>next <em>k</em> tokens</strong> of input. Usually a LL(1) will be enough.</p>
<p>For example, you want to parse a term using <code>&lt;Term&gt; ::= &lt;Number&gt; | (&lt;Expr&gt;)</code>. You can <strong>look ahead</strong> the <strong>next token</strong> (<strong>LL(1)</strong>) to decide whether this <code>&lt;Term&gt;</code> is <strong>intepreted</strong> as a <code>&lt;Number&gt;</code> or an <code>&lt;Expr&gt;</code> </p>
<ul>
<li>if the next token is a digit like <code>1</code>, <code>2</code>, then you know it’s a <code>&lt;Number&gt;</code>;</li>
<li>if the next token is a left parenthesis <code>(</code>, then you know it’s a <code>&lt;Expr&gt;</code>;</li>
<li>Otherwise you should raise an error…</li>
</ul>
<p>Still, take the <a href="https://leetcode.com/problems/basic-calculator-ii" target="_blank" rel="noopener">Basic Calculator II</a> as an example. The <strong>Algorithm</strong> is very simple, consisting of the following parts/steps:</p>
<ul>
<li>A global variable of type string —<code>input</code>— stores the input and another global variable stores the current <strong>index</strong> —<code>idx</code>— of the input.</li>
<li>A <code>lookahead</code> function <strong>reads the next token</strong> but <strong>NOT</strong> <strong>increment</strong> <code>idx</code>.</li>
<li>A <code>getchar</code> function  <strong>reads the next token</strong> <strong>AND</strong> <strong>increment</strong> <code>idx</code>.</li>
<li>Write a function for each <code>Non-terminal</code> , which <strong>determines</strong> which <strong>production</strong> to use, <strong>consume</strong> the input string and <strong>calculate</strong> the result.<ul>
<li>For <code>{}</code> symbols, remember it means that items inside exists <strong>0 or more times</strong>.<ul>
<li>We use a <strong>while loop</strong> — fisrt use <code>lookahead</code> to check whether the <strong>next token</strong> is the beginning of the <strong>item inside <code>[]</code></strong>.</li>
<li>If it is, we recursively call the corresponding function.</li>
</ul>
</li>
<li>For <code>[]</code> symbols, just use an <strong>if</strong> statement to check.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/* BNF</span></span><br><span class="line"><span class="comment">&lt;Expr&gt; ::= &lt;Term&gt; &#123;(+|-) &lt;Term&gt;&#125;</span></span><br><span class="line"><span class="comment">&lt;Term&gt; ::= &lt;Number&gt; &#123;(*|/) &lt;Number&gt;&#125;</span></span><br><span class="line"><span class="comment">&lt;Number&gt; ::= &lt;Digit&gt;&#123;&lt;Digit&gt;&#125;</span></span><br><span class="line"><span class="comment">&lt;Digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> input;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">lookahead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (input[idx] == <span class="string">' '</span>) ++idx;</span><br><span class="line">        <span class="keyword">return</span> input[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">getchar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">expr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = term();</span><br><span class="line">        <span class="keyword">while</span> (lookahead() == <span class="string">'+'</span> || lookahead() == <span class="string">'-'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">'+'</span>) res += term();</span><br><span class="line">            <span class="keyword">else</span> res -= term();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">term</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = number();</span><br><span class="line">        <span class="keyword">while</span> (lookahead() == <span class="string">'*'</span> || lookahead() == <span class="string">'/'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">'*'</span>) res *= number();</span><br><span class="line">            <span class="keyword">else</span> res /= number();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">number</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lookahead()&gt;=<span class="string">'0'</span> <span class="keyword">and</span> lookahead()&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            res = res * <span class="number">10</span> + (getchar()-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        input = s;</span><br><span class="line">        <span class="keyword">return</span> expr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="More-examples-and-solution-code-using-BNF"><a href="#More-examples-and-solution-code-using-BNF" class="headerlink" title="More examples and solution code using BNF"></a>More examples and solution code using BNF</h1><p>The following are all problems on Leetcode. I will provide the BNF and my code.</p>
<h2 id="Ternary-Expression-Parser"><a href="#Ternary-Expression-Parser" class="headerlink" title="Ternary Expression Parser"></a><a href="https://leetcode.com/problems/ternary-expression-parser" target="_blank" rel="noopener">Ternary Expression Parser</a></h2><p>If you want to practice the algorithm above, you would better try this simple one first.</p>
<p>The problem is described as:</p>
<blockquote>
<p>Given a string representing arbitrarily nested ternary expressions, calculate the result of the expression. You can always assume that the given expression is valid and only consists of digits <code>0-9</code>, <code>?</code>, <code>:</code>, <code>T</code> and <code>F</code> (<code>T</code> and <code>F</code> represent True and False respectively).</p>
</blockquote>
<p>Example inputs and outputs:</p>
<ul>
<li>Example 1:</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; Input: &quot;T?2:3&quot;</span><br><span class="line">&gt; Output: &quot;2&quot;</span><br><span class="line">&gt; Explanation: If true, then result is 2; otherwise result is 3.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>Example 2:</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; Input: &quot;T?T?F:5:3&quot;</span><br><span class="line">&gt; Output: &quot;F&quot;</span><br><span class="line">&gt; Explanation: The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:</span><br><span class="line">&gt;              &quot;(T ? (T ? F : 5) : 3)&quot;                   &quot;(T ? (T ? F : 5) : 3)&quot;</span><br><span class="line">&gt;           -&gt; &quot;(T ? F : 3)&quot;                 or       -&gt; &quot;(T ? F : 5)&quot;</span><br><span class="line">&gt;           -&gt; &quot;F&quot;                                    -&gt; &quot;F&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>Solution:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">BNF:</span></span><br><span class="line"><span class="comment">Expr ::= Digit | Ternary</span></span><br><span class="line"><span class="comment">Ternary ::= [F|T] ? Expr : Expr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> input;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">lookahead</span><span class="params">(<span class="keyword">int</span> offset = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input[idx+offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">getchar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">expr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lookahead(<span class="number">1</span>) == <span class="string">'?'</span>) <span class="keyword">return</span> ternary();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> digit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">ternary</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> cond = getchar();</span><br><span class="line">        getchar(); <span class="comment">// discard `?`</span></span><br><span class="line">        <span class="keyword">char</span> res[<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = expr();</span><br><span class="line">        getchar(); <span class="comment">//discard `:`</span></span><br><span class="line">        res[<span class="number">1</span>] = expr();</span><br><span class="line">        <span class="keyword">return</span> res[cond != <span class="string">'T'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">digit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getchar();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">parseTernary</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">        input = expression;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="number">1</span>, expr());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Basic-Calculator-III"><a href="#Basic-Calculator-III" class="headerlink" title="Basic Calculator III"></a><a href="https://leetcode.com/problems/basic-calculator-iii" target="_blank" rel="noopener">Basic Calculator III</a></h2><p>A calculator with <code>+-*/</code> and <code>()</code>.</p>
<ul>
<li>Very similar to the example in the tutorial, except that there is <code>()</code>.<ul>
<li>Remember in the previous example, <code>Term</code> is interpreted as different <code>Number</code>? Now it can also be another <code>Expr</code> with <code>()</code> — I call it <code>Factor</code>, which is either a <code>Number</code> or an <code>Expr</code>.</li>
</ul>
</li>
<li>Actually I extend it so that it can solve <strong>negative number </strong> as well ! — Note the <strong>optional</strong> <code>+/-</code> at the begining of <code>Expr</code> and <code>Factor</code></li>
<li><p>Since that are <code>()</code> in the input string (also a keyword of BNF), I use <code>\(</code> to mean that it is a true <code>(</code> charater in the input string.</p>
</li>
<li><p>Solution</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/* BNF</span></span><br><span class="line"><span class="comment">Expr ::= [+|-] &lt;Term&gt; &#123; +|- &lt;Term&gt;&#125;</span></span><br><span class="line"><span class="comment">Term ::= Factor &#123; (* | / ) &lt;Factor&gt;&#125;</span></span><br><span class="line"><span class="comment">Factor ::= &#123;-&#125; ( Number | ( \( Expr \) )</span></span><br><span class="line"><span class="comment">Number ::= Digit&#123;Digit&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> input;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">lookahead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (input[idx] == <span class="string">' '</span>) ++idx;</span><br><span class="line">        <span class="keyword">return</span> input[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">getchar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> input[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">expr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lookahead() != <span class="string">'+'</span> &amp;&amp; lookahead() != <span class="string">'-'</span>)&#123;</span><br><span class="line">            res += term();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (lookahead() == <span class="string">'+'</span> || lookahead() == <span class="string">'-'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">'+'</span>) res += term();</span><br><span class="line">            <span class="keyword">else</span> res -= term();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">term</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = factor();</span><br><span class="line">        <span class="keyword">while</span> (lookahead() == <span class="string">'*'</span> || lookahead() == <span class="string">'/'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (getchar() == <span class="string">'*'</span>) res *= factor();</span><br><span class="line">            <span class="keyword">else</span> res /= factor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">factor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (lookahead() == <span class="string">'-'</span>)&#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lookahead() == <span class="string">'('</span>)&#123;</span><br><span class="line">            getchar();</span><br><span class="line">            res *= expr();</span><br><span class="line">            getchar(); <span class="comment">// discard ) symbol</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lookahead()&gt;=<span class="string">'0'</span> &amp;&amp; lookahead()&lt;=<span class="string">'9'</span>)</span><br><span class="line">            res *= number();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">number</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lookahead()&gt;=<span class="string">'0'</span> <span class="keyword">and</span> lookahead()&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            res = res * <span class="number">10</span> + (getchar()-<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        input = s;</span><br><span class="line">        <span class="keyword">return</span> expr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Parse-Lisp-Expression"><a href="#Parse-Lisp-Expression" class="headerlink" title="Parse Lisp Expression"></a><a href="https://leetcode.com/problems/parse-lisp-expression" target="_blank" rel="noopener">Parse Lisp Expression</a></h2><p>Here comes a much harder one. Details of problem description please refer to leetcode.</p>
<p>There are <strong>several important points</strong> to note:</p>
<ul>
<li>In the previous example, every <strong>token</strong> is just <strong>a single character</strong>. It doesn’t work for most grammar.<ul>
<li>For example, without seeing the whole word, you will not a <strong>token</strong> starting with <code>w</code> is just a variable name or the keyword <code>while</code> in a programming language like c++.</li>
<li>But this won’t make things complicated. You just need to write a function to <strong>split input string</strong> into an array of tokens according to <strong>delimiter</strong> like <strong>space</strong> — usually including keywords in that grammar too.</li>
</ul>
</li>
<li><strong>LL(1)</strong> is not sufficient here, <strong>LL(2)</strong> is needed. But this is also a easy thing. You just need to provide an <strong>offset</strong> parameter in the <code>lookahead</code> function so that you can <strong>“LOOK INTO”</strong> the <strong>next next token</strong>.<ul>
<li>Example might be <code>Expr ::= Let | Addmult | Term</code>.</li>
<li>Say the input string is <code>(add 1 2)</code> — <code>[&quot;(&quot;, &quot;add&quot;, &quot;1&quot;, &quot;2&quot;, &quot;)&quot;]</code> as tokens — you will not know it should be intepreted into a <code>Addmult</code> or a <code>Let</code> if you just know the next token is <code>(</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/* Try BNF</span></span><br><span class="line"><span class="comment">Expr ::= Let | Addmult | Term </span></span><br><span class="line"><span class="comment">Let ::= \( &#123;Var Expr&#125; Expr \)</span></span><br><span class="line"><span class="comment">Addmult ::= \( (add|mult) Expr Expr \)</span></span><br><span class="line"><span class="comment">Term ::= ([-] Number) | Var</span></span><br><span class="line"><span class="comment">Number ::= digit &#123;digit&#125;</span></span><br><span class="line"><span class="comment">Var :: char &#123;char|digit&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">But for let statement:</span></span><br><span class="line"><span class="comment">Cuz Expr =&gt; Var, you cannot decide whether there's another &#123;Var Expr&#125; or not without LL(2)</span></span><br><span class="line"><span class="comment">But if next == '(', then it's definitely expr()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; variables;</span><br><span class="line">  	<span class="comment">/********* Helper Functions **************/</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; delimiters)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">        <span class="built_in">string</span> token = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: str)&#123;</span><br><span class="line">            <span class="keyword">if</span> (delimiters.find(c) != delimiters.end())&#123;</span><br><span class="line">                <span class="keyword">if</span> (token != <span class="string">""</span>) tokens.push_back(token);</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">' '</span> &amp;&amp; c != <span class="string">'\0'</span>) tokens.push_back(<span class="built_in">string</span>(<span class="number">1</span>, c));</span><br><span class="line">                token = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> token += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="string">""</span>) tokens.push_back(token);</span><br><span class="line">        <span class="comment">//for_each(tokens.begin(),tokens.end(),[](string&amp; t)&#123;cout&lt;&lt;t&lt;&lt;endl;&#125;);</span></span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">lookahead</span><span class="params">(<span class="keyword">int</span> offset=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokens[idx+offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gettoken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;tokens[idx]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> tokens[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isnumber</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span>&#123; <span class="keyword">return</span> (s[<span class="number">0</span>] &gt;= <span class="string">'0'</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">'9'</span>) || s[<span class="number">0</span>] == <span class="string">'-'</span>;&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/********* Parsing Functions **************/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expr</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lookahead() == <span class="string">"("</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lookahead(<span class="number">1</span>) == <span class="string">"let"</span>) res = let();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lookahead(<span class="number">1</span>) == <span class="string">"add"</span> || lookahead(<span class="number">1</span>) == <span class="string">"mult"</span>) res = addmult();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="string">"Error"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res = term();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">let</span><span class="params">()</span></span>&#123;</span><br><span class="line">        gettoken(), gettoken(); <span class="comment">//discard `(`, `let`</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> token;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; var_name;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            token = lookahead();</span><br><span class="line">            <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">'('</span>)&#123; <span class="comment">// must be a expression</span></span><br><span class="line">                res = expr();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isnumber(token))&#123; <span class="comment">// a number</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"---"</span>&lt;&lt;token&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                res = stoi(token);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// then it should be a variable -- token</span></span><br><span class="line">            token = gettoken();</span><br><span class="line">            <span class="keyword">if</span> (lookahead()[<span class="number">0</span>] == <span class="string">')'</span>)&#123;</span><br><span class="line">                res = variables[token].back();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                var_name.push_back(token);</span><br><span class="line">                variables[token].push_back(expr());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gettoken(); <span class="comment">// discard )</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; var: var_name)&#123;</span><br><span class="line">            variables[var].pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addmult</span><span class="params">()</span></span>&#123;</span><br><span class="line">        gettoken(); <span class="comment">// discard (</span></span><br><span class="line">        <span class="built_in">string</span> op = gettoken();</span><br><span class="line">        <span class="keyword">int</span> operand1 = expr(), operand2 = expr();</span><br><span class="line">        gettoken(); <span class="comment">//discard ')'</span></span><br><span class="line">        <span class="keyword">return</span> op==<span class="string">"add"</span>?operand1+operand2:operand1*operand2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">term</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (isnumber(lookahead()))&#123;</span><br><span class="line">            res = number();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> res = var();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">number</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stoi(gettoken());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">var</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> variables[gettoken()].back();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evaluate</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line">        tokens = split(expression, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">'('</span>, <span class="string">')'</span>, <span class="string">' '</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> expr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Basic-Calculator-IV"><a href="#Basic-Calculator-IV" class="headerlink" title="Basic Calculator IV"></a><a href="https://leetcode.com/problems/basic-calculator-iv" target="_blank" rel="noopener">Basic Calculator IV</a></h2><ul>
<li>The hardest one!</li>
<li>No new contents. You should be able to figure it ourt if you have finished the previous example…</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="comment">/* BNF</span></span><br><span class="line"><span class="comment">Expr ::= [+/-] &lt;Term&gt; &#123;+|- &lt;Term&gt;&#125;</span></span><br><span class="line"><span class="comment">Term ::= Factor &#123;* &lt;Factor&gt;&#125;</span></span><br><span class="line"><span class="comment">Factor ::= &#123;-&#125; ( Var | Number | ( \( Expr \) )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Result stored as unordered_map:</span></span><br><span class="line"><span class="comment">    - string -&gt; coff</span></span><br><span class="line"><span class="comment">    - value -&gt; value as coff</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; variables;</span><br><span class="line">    <span class="comment">/* Helper Functions */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; delimiters, <span class="keyword">bool</span> withdel=<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; tokens;</span><br><span class="line">        <span class="built_in">string</span> token = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: str)&#123;</span><br><span class="line">            <span class="keyword">if</span> (delimiters.find(c) != delimiters.end())&#123;</span><br><span class="line">                <span class="keyword">if</span> (token != <span class="string">""</span>) tokens.push_back(token);</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">' '</span> &amp;&amp; c != <span class="string">'\0'</span> &amp;&amp; withdel) tokens.push_back(<span class="built_in">string</span>(<span class="number">1</span>, c));</span><br><span class="line">                token = <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> token += c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="string">""</span>) tokens.push_back(token);</span><br><span class="line">        <span class="comment">//for_each(tokens.begin(),tokens.end(),[](string&amp; t)&#123;cout&lt;&lt;t&lt;&lt;endl;&#125;);</span></span><br><span class="line">        <span class="keyword">return</span> tokens;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split_and_sort</span><span class="params">(<span class="built_in">string</span>&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vars = split(s, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">'*'</span>&#125;, <span class="literal">false</span>);</span><br><span class="line">        sort(vars.begin(), vars.end());</span><br><span class="line">        s = vars[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vars.size(); ++i) s += <span class="string">"*"</span> + vars[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: a)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; j: b)&#123;</span><br><span class="line">                <span class="built_in">string</span> term = i.first + <span class="string">"*"</span> + j.first;</span><br><span class="line">                <span class="keyword">if</span> (term == <span class="string">"*"</span>)&#123; <span class="comment">// both are number</span></span><br><span class="line">                    res[<span class="string">""</span>] += i.second * j.second;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123; <span class="comment">// have variables</span></span><br><span class="line">                    split_and_sort(term);</span><br><span class="line">                    res[term] += i.second * j.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parsing Functions */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">lookahead</span><span class="params">(<span class="keyword">int</span> offset=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokens[idx+offset];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gettoken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;tokens[idx]&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> tokens[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isdigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123; <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; expr()&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (lookahead()[<span class="number">0</span>] != <span class="string">'+'</span> &amp;&amp; lookahead()[<span class="number">0</span>] != <span class="string">'-'</span>)</span><br><span class="line">            res = term();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (lookahead()[<span class="number">0</span>] == <span class="string">'+'</span> || lookahead()[<span class="number">0</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            sign = gettoken()[<span class="number">0</span>]==<span class="string">'+'</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; k: term())&#123;</span><br><span class="line">                res[k.first] += sign * k.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; term()&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res = factor();</span><br><span class="line">        <span class="keyword">while</span> (lookahead()[<span class="number">0</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">            gettoken(); <span class="comment">// discard *</span></span><br><span class="line">            res = multiply(res, factor());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; factor()&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">string</span> token = gettoken();</span><br><span class="line">        <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">'-'</span>)&#123;</span><br><span class="line">            sign = <span class="number">-1</span>;</span><br><span class="line">            token = gettoken();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token[<span class="number">0</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">            res = expr();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t: res) t.second = sign * t.second;</span><br><span class="line">            gettoken(); <span class="comment">// discard ) symbol</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>])) <span class="comment">// a number</span></span><br><span class="line">            res[<span class="string">""</span>] = sign * stoi(token);</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// a variable</span></span><br><span class="line">            <span class="keyword">if</span> (variables.find(token) != variables.end())</span><br><span class="line">                res[<span class="string">""</span>] = sign * variables[token];</span><br><span class="line">            <span class="keyword">else</span> res[token] = sign;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">store_variables</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; evalvars, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; evalints)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; evalvars.size(); ++i)</span><br><span class="line">            variables[evalvars[i]] += evalints[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> da = count(a.begin(), a.end(), <span class="string">'*'</span>);</span><br><span class="line">        <span class="keyword">int</span> db = count(b.begin(), b.end(), <span class="string">'*'</span>);</span><br><span class="line">        <span class="keyword">if</span> (da != db) <span class="keyword">return</span> da &gt; db;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; basicCalculatorIV(<span class="built_in">string</span> expression, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; evalvars, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; evalints) &#123;</span><br><span class="line">        store_variables(evalvars, evalints);</span><br><span class="line">        tokens = split(expression, <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt;&#123;<span class="string">'-'</span>, <span class="string">'+'</span>, <span class="string">'*'</span>, <span class="string">'('</span>, <span class="string">')'</span>, <span class="string">' '</span>, <span class="string">'\0'</span>&#125;);</span><br><span class="line">        tokens.push_back(<span class="string">"$"</span>); <span class="comment">// guard for end of input</span></span><br><span class="line">        <span class="keyword">auto</span> res = expr();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; keys;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sort keys according to term degree and alphabet</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; k: res) keys.push_back(k.first);</span><br><span class="line">        sort(keys.begin(), keys.end(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> value = <span class="string">""</span>; <span class="comment">// store numeric value if there is any</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; k: keys)&#123;</span><br><span class="line">            <span class="keyword">if</span> (res[k] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="string">""</span>) value = to_string(res[<span class="string">""</span>]);</span><br><span class="line">            <span class="keyword">else</span> ans.push_back(to_string(res[k]) + <span class="string">"*"</span> + k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="string">""</span>) ans.push_back(value);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Coding/" rel="tag"># Coding</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/31/monotonic-stack-and-queue/" rel="prev" title="Intuition Between Monotonic Stack and Deque">
      <i class="fa fa-chevron-left"></i> Intuition Between Monotonic Stack and Deque
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/17/dp-over-digit/" rel="next" title="Dynamic Programming Over Digits">
      Dynamic Programming Over Digits <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#What-it-solves-for"><span class="nav-number">1.</span> <span class="nav-text">What it solves for</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Backus-Naur-Form-BNF-Grammar"><span class="nav-number">2.</span> <span class="nav-text">Backus-Naur Form (BNF) Grammar</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Converting-BNF-to-C-code-—-Recursive-Descent-Parsing"><span class="nav-number">3.</span> <span class="nav-text">Converting BNF to C++ code — Recursive Descent Parsing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#More-examples-and-solution-code-using-BNF"><span class="nav-number">4.</span> <span class="nav-text">More examples and solution code using BNF</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Ternary-Expression-Parser"><span class="nav-number">4.1.</span> <span class="nav-text">Ternary Expression Parser</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Calculator-III"><span class="nav-number">4.2.</span> <span class="nav-text">Basic Calculator III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parse-Lisp-Expression"><span class="nav-number">4.3.</span> <span class="nav-text">Parse Lisp Expression</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Calculator-IV"><span class="nav-number">4.4.</span> <span class="nav-text">Basic Calculator IV</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Daniel"
      src="/img/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Daniel</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Crysple" title="GitHub → https://github.com/Crysple" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:gdzejlin@gmail.com" title="E-Mail → mailto:gdzejlin@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-Danny"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Daniel</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
